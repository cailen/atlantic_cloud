#!/usr/bin/python
# -*- coding: utf-8 -*-

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
ANSIBLE_METADATA = {'status': ['preview'],
                    'supported_by': 'community',
                    'version': '0.1.0'}

DOCUMENTATION = '''
---
module: atlantic_cloud
short_description: Create/delete a cloudserver/SSH_key in Atlantic.Net
description:
     - Create/delete a cloudserver in Atlantic.Net and optionally wait for it to be 'running', or deploy an SSH key.
author: "Derek Wiedenhoeft (@cailenletigre)"
options:
  command:
    description:
     - Which target you want to operate on.
    default: cloudserver
    choices: ['cloudserver', 'ssh']
  state:
    description:
     - Indicate desired state of the target.
    default: present
    choices: ['present', 'active', 'absent', 'deleted']
  public_key:
    description:
     - Atlantic.Net public API key.
  private_key:
     - Atlantic.Net private API key.
  instanceid:
    description:
     - Numeric, the cloudserver id you want to operate on.
  servername:
    description:
     - String, this is the name of the cloudserver - must be formatted by hostname rules, or the name of a SSH key.
  planname:
    description:
     - This is the slug of the size you would like the cloudserver created with.
  imageid:
    description:
     - This is the slug of the image you would like the cloudserver created with.
  vm_location:
    description:
     - This is the slug of the region you would like your server to be created in.
  enablebackup:
    description:
     - Optional, Boolean, enables backups for your cloudserver.
    version_added: "1.6"
    default: "no"
    choices: [ "yes", "no" ]
  wait:
    description:
     - Wait for the cloudserver to be in state 'running' before returning.  If wait is "no" an ip_address may not be returned.
    default: "yes"
    choices: [ "yes", "no" ]
  wait_timeout:
    description:
     - How long before wait gives up, in seconds.
    default: 300
  key_id:
    description:
     - The public SSH key you want to add to your account.

notes:
  - none  
requirements:
  - "python >= 2.6"
  - anetpy
'''


EXAMPLES = '''
# Ensure a SSH key is present
# If a key matches this name, will return the ssh key id and changed = False
# If no existing key matches this name, a new key is created, the ssh key id is returned and changed = False

- atlantic_cloud:
    state: present
    command: ssh
    name: my_ssh_key
    key_id: 'ssh-rsa AAAA...'
    public_key: XXX
    private_key: XXX

# Create a new cloudserver
# Will return the cloudserver details including the cloudserver id (used for idempotence)

- atlantic_cloud:
    state: present
    command: cloudserver
    name: mycloudserver
    public_key: XXX
    private_key: XXX
    planname: G2.2GB
    vm_location: USEAST2
    imageid: ubuntu-14.04_64bit
    wait_timeout: 500
  register: my_cloudserver

- debug:
    msg: "ID is {{ my_cloudserver.cloudserver.id }}"

- debug:
    msg: "IP is {{ my_cloudserver.cloudserver.ip_address }}"

# Ensure a cloudserver is present
# If cloudserver id already exist, will return the cloudserver details and changed = False
# If no cloudserver matches the id, a new cloudserver will be created and the cloudserver details (including the new id) are returned, changed = True.

- atlantic_cloud:
    state: present
    command: cloudserver
    instanceid: 123
    servername: mycloudserver
    public_key: XXX
    private_key: XXX
    planname: G2.2GB
    vm_location: USEAST2
    imageid: ubuntu-14.04_64bit
    wait_timeout: 500

# Create a cloudserver with ssh key
# The ssh key id can be passed as argument at the creation of a cloudserver (see ssh_key_ids).
# Several keys can be added to ssh_key_ids as id1,id2,id3
# The keys are used to connect as root to the cloudserver.

- atlantic_cloud:
    state: present
    key_id: XXX
    servername: mycloudserver
    public_key: XXX
    private_key: XXX
    planname: G2-2GB
    vm_location: USEAST2
    imageid: ubuntu-14.04_64bit

'''

import os
import time
import traceback
import logging
from distutils.version import LooseVersion
import json

HAS_ANETPY = False
try:
    import anetpy
    from anetpy.manager import AnetError, AnetManager
    if LooseVersion(anetpy.__version__) >= LooseVersion('0.0.1'):
        HAS_ANETPY = True
except ImportError:
    pass

from ansible.module_utils.basic import AnsibleModule


class TimeoutError(Exception):
    def __init__(self, msg, id_):
        super(TimeoutError, self).__init__(msg)
        self.instanceid = id_


class JsonfyMixIn(object):
    def to_json(self):
        return self.__dict__


class Cloudserver(JsonfyMixIn):
    manager = None

    def __init__(self, cloudserver_json_resp):
        if cloudserver_json_resp.has_key('vm_status'):
            self.vm_status = cloudserver_json_resp['vm_status']
        else:
            self.vm_status = 'NEW'
        self.__dict__.update(cloudserver_json_resp)

    def is_powered_on(self):
        return self.vm_status == 'RUNNING'

    def update_attr(self, attrs=None):
        if attrs:
            for k, v in attrs.iteritems():
                setattr(self, k, v)
        else:
            json_resp = self.manager.show_cloudserver(self.instanceid)
            if json_resp['ip_address']:
                self.update_attr(json_resp)

    def power_on(self):
        assert self.vm_status == 'STOPPED', 'Can only power on a closed one.'
        json_resp = self.manager.power_cycle_cloudserver(self.instanceid)
        self.update_attr(json_resp)

    def ensure_powered_on(self, wait=True, wait_timeout=300):
        if self.is_powered_on():
            return
        if self.vm_status == 'STOPPED':  # powered off
            self.power_on()
        if wait:
            end_time = time.time() + wait_timeout
            while time.time() < end_time:
                time.sleep(min(20, end_time - time.time()))
                self.update_attr()
                if self.is_powered_on():
                    if not self.ip_address:
                        raise TimeoutError('No IP address was found.', self.instanceid)
                    return
            raise TimeoutError('Wait for cloudserver running timeout', self.instanceid)

    def reboot(self, instanceid, reboottype):
        return self.manager.power_cycle_cloudserver(instanceid, reboottype)

    def destroy(self, instanceid):
        return self.manager.destroy_cloudserver(instanceid)

    @classmethod
    def setup(cls, public_key, private_key):
        cls.manager = AnetManager(public_key, private_key)

    @classmethod
    def add(cls, servername, planname, imageid, vm_location, server_qty, key_id=None, enablebackup=False):
        add_resp = []
        enablebackup_lower = str(enablebackup).lower()
        cloudservers = cls.manager.new_cloudserver(servername, planname, imageid, vm_location, server_qty, key_id=key_id, enablebackup=enablebackup_lower)
        for k, v in cloudservers.items():
            add_resp.append(cls(dict((x.lower(), y) for x, y in v.iteritems())))
        return add_resp

    @classmethod
    def find(cls, instanceid=None, servername=None):
        resp = []
        # If no specifics listed, return the all of the servers
        if not instanceid and not servername:
            cloudservers = cls.getter()
            return cloudservers
        else:
            cloudservers = cls.getter()
            # Check first by instanceid.  This will be unique.
            for cloudserver in cloudservers:
                if cloudserver.instanceid == str(instanceid):
                    cloudserver = cls.getter(cloudserver.instanceid)
                    return cloudserver
            # Failing that, check by servername.
            for cloudserver in cloudservers:
                if cloudserver.vm_description == servername:
                    resp.append(cls.getter(cloudserver.instanceid))
                return resp
        return False

    @classmethod
    def getter(cls, instanceid=None):
        getResp2 = []
        getResp = []
        # Return all servers
        if not instanceid:
            cloudservers = cls.manager.all_active_cloudservers()
            for k, v in cloudservers.items():
                getResp.append(dict((x.lower(), y) for x, y in v.iteritems()))
            for v in getResp:
                getResp2.append(cls(v))
            return getResp2
        # Return one server's details
        else:
            cloudserver = cls.manager.show_cloudserver(instanceid)
            for k, v in cloudserver.items():
                getResp.append(cls(dict((x.lower(), y) for x, y in v.iteritems())))
            return getResp

class SSH(JsonfyMixIn):
    manager = None

    def __init__(self, key_id_json_resp):
        self.__dict__.update(key_id_json_resp)
    update_attr = __init__

    @classmethod
    def setup(cls, public_key, private_key):
        cls.manager = AnetManager(public_key, private_key)

    @classmethod
    def find(cls, key_name):
        if not key_name:
            return False
        keys = cls.list_all()
        for key in keys:
            if key.key_name == key_name:
                return key
        return False

    @classmethod
    def list_all(cls):
        json_resp = cls.manager.all_ssh_keys()
        return map(cls, json_resp)

def core(module):
    def getkeyordie(k):
        v = module.params[k]
        if v is None:
            module.fail_json(msg='Unable to load %s' % k)
        return v
    try:
        public_key = module.params['public_key']
        private_key = module.params['private_key']
    except KeyError as e:
        module.fail_json(msg='Unable to load %s' % e.message)

    changed = True
    command = module.params['command']
    state = module.params['state']

    if command == 'server':
        Cloudserver.setup(public_key, private_key)

        #List the servers, taking into account instanceid or servername params
        cloudservers = Cloudserver.find(instanceid=module.params['instanceid'],
                    servername=module.params['servername'])

        #This basically says give a list of all active servers for this account.
        if not module.params['instanceid'] and not module.params['servername']:
            cloudservers = ([cloudserver.to_json() for cloudserver in cloudservers])
            module.exit_json(changed=changed, msg="Current list of servers:", results=cloudservers)

        if state in ('active', 'present'):

                if cloudservers:
                    
                    # Server names are not unique, so there could be a list. (Not planname because a server could
                    # already be named the same name)
                    if module.params['servername'] and not module.params['planname']:
                        cloudservers = ([cloudserver.to_json() for cloudserver in cloudservers])
                        msg="Detail of servers (by name):"
                    
                    # Reboot the server
                    elif (len(cloudservers) == 1) and module.params['reboottype'] and module.params['instanceid']:
                        for cloudserver in cloudservers:
                            cloudservers = [cloudserver.reboot(instanceid=module.params['instanceid'], reboottype=module.params['reboottype']) for cloudserver in cloudservers]
                            msg = "Rebooted the server"
                    
                    # Do not reboot multiple servers
                    elif (len(cloudservers) > 1) and module.params['reboottype'] and module.params['instanceid']:
                        module.fail_json(changed=False, msg='Multiple server reboots are not supported yet.')
                    
                    # Print out the details of a server based on instanceid
                    elif module.params['instanceid']:
                        msg = 'Details of the server (by instanceid):'
                                        
                # Create a new server if you've made it this far
                if not cloudservers:
                    cloudservers = Cloudserver.add(
                        servername=getkeyordie('servername'),
                        planname=getkeyordie('planname'),
                        imageid=getkeyordie('imageid'),
                        vm_location=getkeyordie('vm_location'),
                        server_qty=module.params['server_qty'],
                        key_id=module.params['key_id'],
                        enablebackup=module.params['enablebackup'],
                        )

                    msg="New server credentials:"
                
                # Make sure the server is on (present/active)
                for cloudserver in cloudservers:
                    if cloudserver.is_powered_on():
                        changed = False
                    cloudserver.ensure_powered_on(
                        wait=getkeyordie('wait'),
                        wait_timeout=getkeyordie('wait_timeout'),
                        )
                # Print out the results
                cloudservers = ([cloudserver.to_json() for cloudserver in cloudservers])
                module.exit_json(changed=changed, msg=msg, results=cloudservers)
        
        # Delete a server or check to see if it doesn't exist
        elif state in ('absent', 'deleted'):
            # First, try to find a cloudserver by instanceid.
            for cloudserver in cloudservers:
                if not cloudserver or (len(cloudservers) > 1):
                    module.exit_json(changed=False, msg='The server is not found or multiple servers were provided for deletion, which is not supported yet.')
                cloudserver.destroy(module.params['instanceid'])
                module.exit_json(changed=True, msg="The server has been removed.", results=cloudserver.to_json())

    elif command == 'ssh':
        SSH.setup(public_key, private_key)
        name = getkeyordie('name')
        if state in ('active', 'present'):
            key = SSH.find(name)
            if key:
                module.exit_json(changed=False, key_id=key.to_json())
            key = SSH.add(name, getkeyordie('key_id'))
            module.exit_json(changed=True, key_id=key.to_json())

        elif state in ('absent', 'deleted'):
            key = SSH.find(name)
            if not key:
                module.exit_json(changed=False, msg='SSH key with the name of %s is not found.' % name)
            key.destroy()
            module.exit_json(changed=True)


def main():
    module = AnsibleModule(
        argument_spec = dict(
            command = dict(choices=['server', 'plan', 'image', 'ssh']),
            state = dict(choices=['active', 'present', 'absent', 'deleted'], default='present'),
            public_key = dict(type='str'),
            private_key = dict(type='str'),
            servername = dict(type='str'),
            planname = dict(),
            imageid = dict(),
            vm_location = dict(),
            enablebackup = dict(type='bool', default='no'),
            instanceid = dict(type='int'),
            wait = dict(type='bool', default=True),
            wait_timeout = dict(default=300, type='int'),
            key_id = dict(type='str'),
            server_qty = dict(type='int'),
            reboottype = dict(type='str',)
        ),
        #required_together = (
        #    ['planname', 'imageid', 'vm_location', 'servername'],
        #    ['instanceid', 'reboottype'],
        #),
        #required_one_of = (
        #    ['command']
        #),
    )


    if not HAS_ANETPY:
        module.fail_json(msg='anetpy >= 0.1.0 required for this module')

    try:
        core(module)
    except TimeoutError as e:
        module.fail_json(msg=str(e), id=e.id)
    except (AnetError, Exception) as e:
        module.fail_json(msg=str(e), exception=traceback.format_exc())

if __name__ == '__main__':
    main()
